2η Εργασία Προγραμματισμός Συστήματος 
Χριστόπουλος Βασίλειος 
ΑΜ:1115201500181

Compilation: make
Execution: ./jobExecutor -d <PathFile> -w <Workers>


Γενικότερα σε αυτην την εργασια εχουν χρησιμοποιηθει components της 1ης εργασίας στα οποια θα γίνονται αναφορές κατα την περιγραφή.
Αρχικα, εχει εφαρμοστει ελεγχος λαθος εντολης εκτελεσης ο οποιος παραγει αντιστοιχα μηνυματα.
Στη συνεχεια, το αρχικο προγραμμα (main) δημιουργει τα αρχεια των pipes των οποιων τα ονοματα θα παρουν οι Workers και ο Executor κατα τη φιλοσοφια που θα περιγραφει στη συνεχεια.
Για καθε ζευγαρι Worker-Executor υπαρχουν 2 pipes, ενα που μονο στελνει ο Executor και διαβαζει ο Worker και ενα αντιστροφα. Τα πρωτα, ονομαζονται fn_i και τα δευτερα f_i οπου i το ζευγαρι. 
Η αρχική διεργασια, κανει spawn ενα παιδι το οποιο ειναι ο πρωτος Worker, στη συνεχεια μεσω μιας επαναληψης δημιουργει τα επομενα N-1 παιδια (Workers) και στη συνεχεια μπαινει στη ρουτινα του ως Job Executor. Καθε Worker παιρνει μονο το ονομα του pipe στο οποιο γραφει και εκεινου στο οποιο διαβαζει, ενω ο Executor παιρνει τα ονοματα ολων των pipes.Η καθε διεργασια που δημιουργηθηκε ως Worker, κανει exec το προγραμμα Worker.c το οποιο υλοποιει την λειτουργικοτητα των Workers.

ΕΠΙΚΟΙΝΩΝΙΑ:
Με την εναρξη, ολοι ανοιγουν τα pipes που εχουν διαθεσιμα και παιρνουν τα αντιστοιχα descriptors. Ο Executor ανοιγει το αρχειο με τα paths και τα χωριζει αναλογα με το ποσα ειναι και ποσοι ειναι οι Workers, και στη συνεχεια γραφει το αντιστοιχο περιεχομενο σε καθε pipe. Αντιχτοιχα οι Workers αφου ανοιξουν το pipe διαβαζουν την τιμη που εχει μεσα. Στη συνεχια ο Executor περιμενει input απο τον χρηστη ενω ο καθε Worker ξεκινα την διαδικασια αποδηκευσης των δεδομενων η οποια θα περιγραφει στη συνεχεια. Εφοσον αποθηκευσει, περιμενει signal απο τον Executor για να παει να διαβασει απο το αντιστοιχο pipe την λειτουργια που πρεπει να εκτελεσει (search,maxcount,exit κλπ).Αφου διαβαζει, εκτελει τις καταλληλες ενεργειες (θα περιγραφουν στη συνεχεια) και μετα ξαναπεριμενει signal. Η επαναληψη αυτη σταματαει εφοσον εχει διαβαστει /exit απο το pipe η εφοσον η διεργασια ελαβε SIGTERM. 
Απο την μερια του Executor αφου λαβει το command το γραψει στα pipes και στειλει σημα στους Workers να ξυπνησουν, πρεπει να περιμενει απαντηση. Αυτο γινεται μεσω της select η οποια θα εκτελεστει Worker φορες για να γινει catch ακομα και η χειροτερη περιπτωση οπου θα λαμβανονται ενα ενα τα events. Καθε φορα που κανει catch η select και επιστρεψει θετικη τιμη, ψαχνει ποιος descriptor ειναι μεσα στο set των events, και απο εκει παει και διαβαζει. Καθε φορα που λαμβανει απαντηση απο ενα pipe, βαζει μια μη αρνητικη τιμη σε ενα πινακα ως ενδειξη οτι εχει απαντηθει. Εαν μετα απο ολες τις select υπαρχει αρνητικη τιμη σε αυτον τον πινακα, αυτο σημαινει οτι δεν εχει ερθει απαντηση απο καποιον descriptor,δηλαδη η διεργασια εχει τερματιστει, οπου εκει γενιεται καινουργια.Οταν ενας Worker τερματιζει απο SIGTERM τοτε δεν στελνει τα matches που εκανε στον Executor, περιπτωση που ελεγχεται μεσω της Global μεταβλητης που ελεγχει ο handler του SIGTERM. Τελος, οταν ο Executor λαμβανει exit, εκτελει αλλη μια ρουτινα select για να λαβει τα Μatches μεσω των pipes, και μετα περιμενει τα παιδια να τελειωσουν με μια waitpid, και αποδεσμευει με τη σειρα του ολη τη μνημη που ειχε.

ΑΠΟΘΗΚΕΥΣΗ ΔΕΔΟΜΕΝΩΝ ΑΠΟ WORKER:
Για την αποθηκευση οι κυριες δομες ειναι το Trie της 1ης εργασιας χωρις αλλαγες, το PostingList το οποιο εχει ιδια λειτουργια μονο που τωρα τα πεδια του ειναι το ονομα του αρχειου που βρισκεται μια λεξη, η γραμμη στην οποια βρισκεται και η συχνοτητα της, και ενα dynamic HashTable με αλυσιδα υπερχειλισης μεγιστου μεγεθους οσο τα αρχεια, το οποιο εχει ως κλειδι τον αριθμο της γραμμης και καθε entry του εχει ονομα αρχειου και περιεχομενο γραμμης, και χρησιμοποιειται αντι για το Map της 1ης εργασιας για να βρισκεται το περιεχομενο μιας γραμμης.

COMMANDS:

/search word1 word2 .. wordn -d deadline

Οταν ο Executor λαμβανει search τοτε στελνει τις λεξεις στον Worker, και στη συνεχεια εκτελει τη ρουτινα με την select που περιγραφηκε. Οταν λαβει απαντηση, κοιταει τον χρονο που εκανε να τη λαβει, αν ειναι εντος deadline βαζει την τιμη 1 στον πινακα came που σημαινει οτι ειναι valid απαντηση, και την εμφανιζει, αλλιως βαζει 0.Αντιστοιχα, ο Worker εκτελει την συναρτηση για την search οπου συλλεγει τα απαραιτητα περιεχομενα για καθε λεξη, κανοντας push καθε προταση σε ενα Queue που αποτρεπει τα διπλοτυπα (βλ 1η εργασια) και στη συνεχεια κανει merge ολα τα περιεχομενα και τα επιστρεφει ως ενα string.

/maxcount word
Ο executor στελνει το string "/maxcount <word>" στον Executor και περιμενει απαντησεις, οταν ερθει η καθε μια την αποθηκευει σε πινακες (path, num) και στο τελος συγκρινει την μεγαλυτερη. Ο Worker αφου βρει το postinglist Που αντιστοιχει στην λεξη επιστρεφει το μεγαλυτερο frequency που υπαρχει. 
/mincount word 
Αντιχτοιχη λειτουργια με την /maxcount

/wc 
O worker συλλεγει τις απαραιτητες πληροφοριες απο συναρτησεις που κανουν τους υπολογισμους με ενα iterate στα περιεχομενα του hash table. Ο Executor αθροιζει μεταξυ τους ολα τα περιεχομενα και τα επιστρεφει στον χρηστη.


Scritps: 
Βρισκονται ολα σε ενα αρχειο, στο οποιο δινεται ορισμα ο φακελος log, με τα logfiles 
Key Most Frequently Found: 
Για καθε αρχειο, για καθε γραμμη, εαν η εντολη ειναι search τοτε εαν υπαρχει αρχειο που βρεθηκε αυτη η λεξη, αποθηκευεται σε εναν πινακα η λεξη, και στο τελος αφαιρουνται τα διπλοτυπα απο τον πινακα και εμφανιζεται το μεγεθος του.
Max Word:
Καθε φορα που βρισκεται search με λεξη που υπαρχει σε κειμενα, μετριεται σε ποσα αρχεια υπαρχει, και στη συνεχεια γινεται lookup σε ενα πινακα που για καθε λεξη εχει τα occurences της, και εαν υπαρχει η λεξη τοτε προσθετει τα occurences που βρεθηκαν εκεινη τη στιγμη, αν δεν υπαρχει δημιουργει καινουργιο παιδιο με τιμη τα occurences που βρεθηκαν, μολςι τελειωσει ολη αυτη η διαδικασια, ψαχνεται το μεγιστο.
Min Word:
Απο τον πινακα του Max Word, βρισκεται το ελαχιστο. 

